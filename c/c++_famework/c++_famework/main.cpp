#include <iostream>
#include <windows.h>

using namespace std; //원래는 using std::cout, cin 등등 이렇게 해줘야 하는데 전체적으로 예외처리하는것

//******************************************namespace*********************************************
//영역을 별도로 나눴다 생각하면 됨

//namespace aaa
// {
// }
//namespace bbb
// {
// }
//namespace 접근 ::
// int main()
// {
// aaa::
// }
//************************************************************************************************



//class는 namespace의 기능을 포함하고 있다



/*
//************************************★★CLASS★★********************************************************
//5가지 특징 (oop의 특징) 객체지향 프로그래밍

//1, 정보은닉 -> 데이터 비공개화(승인작업 등등)
//2, 캡슐화   -> 데이터랑 함수를 묶어서 사용하는 의미, ★(*기능차이를 의미함*)(자기함수를 사용)(자신만의 기능)★
//3, 상속     -> 족보비슷~ (계층구조(계단형식))
//4, 추상화   -> 추상적 (대상이 특정되지 않음) (인스턴스화) (객체화되지않음)
//5, 다형성   -> 다양한형태 (학생 -> 안경낀학생, 마스크낀학생 등등..)

//### 모든 객체는 클레스로 만들어져 있지만, 모든 클레스는 객체가아님 ###

//getter, setter
//namespace개념
//생성자, 소멸자, 복사생성자
//가상함수, 순수가상함수
//오버로딩 ,오버라이딩
//연산자 오버로딩



struct Object
{

};
//밑에 클래스가 결국 구조체임 


class Object
{
//private: -> 비공개형태 (네임스페이스로 접근 :: 안됨)

//protected: -> 상속간의 접근이 가능, (부분적인 공개형태)

//public: -> 공개형태

//★★프렌드 키워드도 있음 객체지향을 무시할수 있음(나중에 필요할때 알아볼것)★★


/////////static 붙히면 딱 그것하나만 만들어짐 ex) static int a, int a 전혀 다름/////////


	//캡슐화 설명▼
private: //데이터는 프라이빗
	int inumber;
protected:

public: //기능은 공개
	void setnumber(int _number)
	{
		inumber = _number;
	}
};
//****************************************************************************************************
*/




/*
//*********************생성자, 소멸자, 복사생성자***********************************************************************
//생성자, 소멸자 = 호출이 없어도 자동으로 호출이됨(c#에서는 자동아님)
class Object1
{
public:
	Object1()
	{
		//생성자
		cout << "생성자" << endl;
	}

	Object1(string _str)
	{
		//복사 생성자 (매개변수 필요), 복사 생성자는 자동호출 되지않음 (복사생성자가 호출되면 생성자는 호출되지않음)
		cout << _str << endl;
	}

	Object1(string _str, float _f)
	{
		//복사 생성자 (매개변수 필요), 복사 생성자는 자동호출 되지않음 (복사생성자가 호출되면 생성자는 호출되지않음)
		cout << _str << _f << endl;
	}

	~Object1()
	{
		//소멸자
		cout << "소멸자" << endl;
	}
};
//****************************************************************************************************
*/



/*
//******************************************상속********************************************************
class parent
{
protected:
	int number;
};


class child : public parent //object2를 상속받음
{
public:
	void output()
	{
		cout << number << endl;
	}
};
//******************************************************************************************************
*/



/*
//******************************************추상화, 오버로딩, 오버라이딩, 가상함수********************************************************
// 추상화, 순수가상함수 -> virtual void 함수이름() = 0;    ★★★★★(=0이게중요)  ==  (=0 을 PURE 이렇게 표현)★★★★★    (즉 pure이 들어가면 순수가상함수이자 추상화)
// 가상함수 -> virtual void 함수이름() {}   중괄호 즉 몸체를 가짐
// 순수가상, 가상함수는 무조건 자식도 그함수를 가져야함


//오버로딩 -> (상속아니라도 가능) (함수타입의 복사생성자) (함수, 같은이름 함수 ★★★(매개변수 다르게)★★★)
//오버라이딩 -> (상속이어야 사용 가능) 가상함수 필요, ex) void 함수() override      // 클레스의 형태에 따라 실행되는 함수가 달라짐     //즉 클레스의 영역에서 호출선택
//오버로딩, 오버라이딩 은 함수의 호출을 선택하는 기능
class parent
{
protected:
	//virtual void output() = 0; //PURE; 이렇게 사용 (순수가상함수)
	//virtual void input() {} //(가상함수)

	virtual void output1()PURE;                  //오버로딩, 순수가상함수, 추상화
	virtual void output1(string _str)PURE;       //오버로딩, 순수가상함수, 추상화             
};


class child : public parent //object2를 상속받음
{
public:
	virtual void output1() override {}                  //오버로딩&오버라이딩
	virtual void output1(string _str) override {}       //오버로딩&오버라이딩
};


//******************************************************************************************************
*/




//***************************************연산자오버로딩**********************************************************




//**************************************************************************************************************






int main(void)
{
	/*
    //////////////////////////////////////////////캡슐화 설명▼
	Object o1, o2;

	o1.setnumber(10); //기능은 공개되어서 사용가능
	o2.setnumber(20); //기능은 공개되어서 사용가능
	//////////////////////////////////////////////
	*/




	/*
    //*********************★생성자, 소멸자, 복사생성자★***********************************************************************
	Object1 o3; //생성자 호출
	Object1 o3 = Object1("복사생성자", 0.1); //복사생성자 호출
	return 0; //소멸자 호출
	//********************************************************************************************************************
	*/



	/*
	//********************★추상화, 오버로딩, 오버라이딩, 가상함수★***********************************************************
	parent* p[3];

	//p[0] = new parent; //추상 클래스라서 안됨
	p[0] = new child;

	//*********************************************************************************************************************
	*/




	//********************★연산자오버로딩★********************************************************************************
	



	//*********************************************************************************************************************



	return 0; //소멸자 호출
}