#include <iostream>

using namespace std; //원래는 using std::cout, cin 등등 이렇게 해줘야 하는데 전체적으로 예외처리하는것

//******************************************namespace*********************************************
//영역을 별도로 나눴다 생각하면 됨

//namespace aaa
// {
// }
//namespace bbb
// {
// }
//namespace 접근 ::
// int main()
// {
// aaa::
// }
//************************************************************************************************



//class는 namespace의 기능을 포함하고 있다



//*********************class***********************************************************************
//5가지 특징 (oop의 특징) 객체지향 프로그래밍

//1, 정보은닉 -> 데이터 비공개화(승인작업 등등)
//2, 캡슐화   -> 데이터랑 함수를 묶어서 사용하는 의미, ★(*기능차이를 의미함*)(자기함수를 사용)(자신만의 기능)★
//3, 상속     -> 족보비슷~ (계층구조(계단형식))
//4, 추상화   -> 추상적 (대상이 특정되지 않음) (인스턴스화) (객체화되지않음)
//5, 다형성   -> 다양한형태 (학생 -> 안경낀학생, 마스크낀학생 등등..)

//### 모든 객체는 클레스로 만들어져 있지만, 모든 클레스는 객체가아님 ###

//getter, setter
//namespace개념
//생성자, 소멸자, 복사생성자
//가상함수, 순수가상함수
//오버로딩 ,오버라이딩
//연산자 오버로딩


/*
struct Object
{

};
밑에 클래스가 결국 구조체임 
*/

class Object
{
//private: -> 비공개형태 (네임스페이스로 접근 :: 안됨)

//protected: -> 상속간의 접근이 가능, (부분적인 공개형태)

//public: -> 공개형태

//★★프렌드 키워드도 있음 객체지향을 무시할수 있음(나중에 필요할때 알아볼것)★★


/////////static 붙히면 딱 그것하나만 만들어짐 ex) static int a, int a 전혀 다름/////////


	//캡슐화 설명▼
private: //데이터는 프라이빗
	int inumber;
protected:

public: //기능은 공개
	void setnumber(int _number)
	{
		inumber = _number;
	}
};
//****************************************************************************************************



/*
//*********************생성자, 소멸자, 복사생성자***********************************************************************
//생성자, 소멸자 = 호출이 없어도 자동으로 호출이됨(c#에서는 자동아님)
class Object1
{
public:
	Object1()
	{
		//생성자
		cout << "생성자" << endl;
	}

	Object1(string _str)
	{
		//복사 생성자 (매개변수 필요), 복사 생성자는 자동호출 되지않음 (복사생성자가 호출되면 생성자는 호출되지않음)
		cout << _str << endl;
	}

	Object1(string _str, float _f)
	{
		//복사 생성자 (매개변수 필요), 복사 생성자는 자동호출 되지않음 (복사생성자가 호출되면 생성자는 호출되지않음)
		cout << _str << _f << endl;
	}

	~Object1()
	{
		//소멸자
		cout << "소멸자" << endl;
	}
};
//****************************************************************************************************
*/




//******************************************상속********************************************************
class parent
{
protected:
	int number;
};


class child : public parent //object2를 상속받음
{
public:
	void output()
	{
		cout << number << endl;
	}
};


class object111
{
public:
	
};

//******************************************************************************************************




int main(void)
{
    //////////////////////캡슐화 설명▼
	Object o1, o2;

	o1.setnumber(10); //기능은 공개되어서 사용가능
	o2.setnumber(20); //기능은 공개되어서 사용가능

    //*********************★생성자, 소멸자, 복사생성자★***********************************************************************
	//Object1 o3; //생성자 호출
	//Object1 o3 = Object1("복사생성자", 0.1); //복사생성자 호출
	//return 0; //소멸자 호출
	//********************************************************************************************************************

	//********************★상속★*********************************************************************************************



	return 0; //소멸자 호출
}