#include <iostream>
#include <windows.h>

using namespace std; //원래는 using std::cout, cin 등등 이렇게 해줘야 하는데 전체적으로 예외처리하는것

//******************************************namespace*********************************************
//영역을 별도로 나눴다 생각하면 됨

//namespace aaa
// {
// }
//namespace bbb
// {
// }
//namespace 접근 ::
// int main()
// {
// aaa::
// }
//************************************************************************************************



//class는 namespace의 기능을 포함하고 있다



/*
//************************************★★CLASS★★********************************************************
//5가지 특징 (oop의 특징) 객체지향 프로그래밍

//1, 정보은닉 -> 데이터 비공개화(승인작업 등등)
//2, 캡슐화   -> 데이터랑 함수를 묶어서 사용하는 의미, ★(*기능차이를 의미함*)(자기함수를 사용)(자신만의 기능)★
//3, 상속     -> 족보비슷~ (계층구조(계단형식))
//4, 추상화   -> 추상적 (대상이 특정되지 않음) (인스턴스화) (객체화되지않음)
//5, 다형성   -> 다양한형태 (학생 -> 안경낀학생, 마스크낀학생 등등..)

//### 모든 객체는 클레스로 만들어져 있지만, 모든 클레스는 객체가아님 ###

//getter, setter
//namespace개념
//생성자, 소멸자, 복사생성자
//가상함수, 순수가상함수
//오버로딩 ,오버라이딩
//연산자 오버로딩



struct Object
{

};
//밑에 클래스가 결국 구조체임 


class Object
{
//private: -> 비공개형태 (네임스페이스로 접근 :: 안됨)

//protected: -> 상속간의 접근이 가능, (부분적인 공개형태)

//public: -> 공개형태

//★★프렌드 키워드도 있음 객체지향을 무시할수 있음(나중에 필요할때 알아볼것)★★


/////////static 붙히면 딱 그것하나만 만들어짐 ex) static int a, int a 전혀 다름/////////


	//캡슐화 설명▼
private: //데이터는 프라이빗
	int inumber;
protected:

public: //기능은 공개
	void setnumber(int _number)
	{
		inumber = _number;
	}
};
//****************************************************************************************************
*/




/*
//***************************************생성자, 소멸자, 복사생성자*****************************************************
//생성자, 소멸자 = 호출이 없어도 자동으로 호출이됨(c#에서는 자동아님)
class Object1
{
public:
	Object1()
	{
		//생성자
		cout << "생성자" << endl;
	}

	Object1(string _str)
	{
		//복사 생성자 (매개변수 필요), 복사 생성자는 자동호출 되지않음 (복사생성자가 호출되면 생성자는 호출되지않음)
		cout << _str << endl;
	}

	Object1(string _str, float _f)
	{
		//복사 생성자 (매개변수 필요), 복사 생성자는 자동호출 되지않음 (복사생성자가 호출되면 생성자는 호출되지않음)
		cout << _str << _f << endl;
	}

	~Object1()
	{
		//소멸자
		cout << "소멸자" << endl;
	}
};
//****************************************************************************************************
*/



/*
//******************************************상속********************************************************
class parent
{
protected:
	int number;
};


class child : public parent //object2를 상속받음
{
public:
	void output()
	{
		cout << number << endl;
	}
};
//******************************************************************************************************
*/



/*
//******************************************추상화, 오버로딩, 오버라이딩, 가상함수********************************************************
// 추상화, 순수가상함수 -> virtual void 함수이름() = 0;    ★★★★★(=0이게중요)  ==  (=0 을 PURE 이렇게 표현)★★★★★    (즉 pure이 들어가면 순수가상함수이자 추상화)
// 가상함수 -> virtual void 함수이름() {}   중괄호 즉 몸체를 가짐

// (가상함수)는 할당해준거 실행
// (일반함수)는 자기꺼 그대로 실행

// 순수가상, 가상함수는 무조건 자식도 그함수를 가져야함


//오버로딩 -> (상속아니라도 가능) (★함수타입의 복사생성자★) (함수, 같은이름 함수 ★★★(매개변수 다르게)★★★)
//오버라이딩 -> (상속이어야 사용 가능) 가상함수 필요, ex) void 함수() override      // 클레스의 형태에 따라 실행되는 함수가 달라짐     //즉 클레스의 영역에서 호출선택
//오버로딩, 오버라이딩 은 함수의 호출을 선택하는 기능
class parent
{
protected:
	//virtual void output() = 0; //PURE; 이렇게 사용 (순수가상함수)
	//virtual void input() {} //(가상함수)

	virtual void output1()PURE;                  //오버로딩, 순수가상함수, 추상화
	virtual void output1(string _str)PURE;       //오버로딩, 순수가상함수, 추상화             
};


class child : public parent //object2를 상속받음
{
public:
	virtual void output1() override {}                  //오버로딩&오버라이딩
	virtual void output1(string _str) override {}       //오버로딩&오버라이딩
};


//******************************************************************************************************
*/





// //**************************************[&] 사용 용도************************************************

// 1, 2항연산자로 사용
//    & 이  1번만 쓰였다면 비트연산
//    && 이 2번 쓰였다면 비교연산(논리연산)
// 
// 2, 단항 연산자로 사용
//    &변수 이 변수 앞쪽에 붙은경우 주소값
//    자료형(형태)& 이 자료형 뒷쪽에 붙은 경우 [레퍼런스 연산자] ex) int& i = 1;



////// 레퍼런스 연산자 /////////

////// 매개변수의 값을 -> 복사하는게 아니라 원본을 가져오는것 //////

//******************************************************************************************************




/*
//***************************************연산자오버로딩**********************************************************
// 연산자 오버로딩 이란 : ★★★함수, 클래스 등 연산할수 없는 것을 연산하게 만들어줌★★★
// 
// int i = 1;
// 
// i << 1; (옆으로 한칸 민다는 뜻)
// 곱하기 한거랑 같음
// 
// i >> 1;
// 나누기 2한거랑 같음 ( 나누기2랑, 곱하기0.5 는 똑같음)
// 
// 0000 0001 (<<1) 0000 0010 (>>1) 0000 0001 





//예제1 더하기
class object
{
private:
	int number;
public:
	int getnumber()
	{
		return number;
	}
public:
	object& operator+=(object& _obj)               //연산자 오버로딩
	{
	 	   this->number += _obj.number;            //this 는 나자신이라는 뜻 (포인터임)
	 	   return (*this);
	}
	object() {}
	object(int _number) : number(_number) {}       //여기서  number(_number) 은  number = _number 이뜻이랑 똑같음
	~object() {}                                   //소멸자
};




//예제2 빼기
class object1
{
private:
	int number;
public:
	int getnumber()
	{
		return number;
	}
public:
	object1& operator-=(object1& _obj)
	{
		this->number -= _obj.number;
		return (*this);
	}
	object1() {}
	object1(int _number)
	{
		number = _number;
	}
	~object1() {}
};



//예제3 나누기
class object2
{
private:
	int number;
public:
	int getnumber()
	{
		return number;
	}
public:
	object2& operator/=(object2& _obj)
	{
		this->number /= _obj.number;
		return (*this);
	}
	object2() {}
	object2(int _number)
	{
		number = _number;
	}
	~object2() {}
};



//예제4 ++
class object3
{
private:
	int number;
public:
	int getnumber()
	{
		return number;
	}
public:
	object3& operator++()
	{
		this->number++;
		return (*this);
	}
	object3() {}
	object3(int _number)
	{
		number = _number;
	}
	~object3() {}
};


//**************************************************************************************************************
*/


int main(void)
{
	/*
    //////////////////////////////////////////////캡슐화 설명▼
	Object o1, o2;

	o1.setnumber(10); //기능은 공개되어서 사용가능
	o2.setnumber(20); //기능은 공개되어서 사용가능
	//////////////////////////////////////////////
	*/




	/*
    //******************************************★생성자, 소멸자, 복사생성자★**************************************************
	Object1 o3; //생성자 호출
	Object1 o3 = Object1("복사생성자", 0.1); //복사생성자 호출
	return 0; //소멸자 호출
	//********************************************************************************************************************
	*/




	/*
	//******************************************★추상화, 오버로딩, 오버라이딩, 가상함수★*************************************
	parent* p[3];

	//p[0] = new parent; //추상 클래스라서 안됨
	p[0] = new child;

	//*********************************************************************************************************************
	*/




	/*
	//*******************************************★연산자오버로딩★*********************************************************
	object o1(1), o2(2);
	
	o1 += o2;   //이게 원래 안됨, 하지만 위에 연산자 오버로딩을 해줌으로써 class 끼리 더할수 있게 만들어줌

	cout << o1.getnumber() << endl;


	object1 o3(5), o4(3);

	o3 -= o4;

	cout << o3.getnumber() << endl;


	object2 o5(10), o6(2);

	o5 /= o6;

	cout << o5.getnumber() << endl;


	object3 o7(10);

	++o7;

	cout << o7.getnumber() << endl;


	//*********************************************************************************************************************
	*/


	return 0; //소멸자 호출
}